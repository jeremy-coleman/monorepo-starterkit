


interface IListingReviewListAppProps extends IAppHostProps {
    listingId: number;
  }


class ListingReviewListApp extends React.Component<{ match: IRequest }, never> implements WithUserCredentials {
    get host(): IAppHost {
      return this.props.match.host;
    }
    get userProfile(): IUserProfile {
      return this.props.match.userProfile;
    }
    get isAdmin(): boolean {
      return true
      //return UserAdminContext.value(this.userProfile);
    }
  
    _titleSetDisposer: IReactionDisposer;
    _listing: ListingModel;
    get listing(): IListingModel {
      if (!this._listing) {
        this._listing = new ListingModel();
      }
      return this._listing;
    }
    get isOwner() {
      return isOwner(this.listing, this.userProfile);
    }
    _setupListing(props: IAppProps) {
      const listingId = props.match.params.listingId;
      this.listing.id = listingId;
    }
    _onRenderListing = () => {
      return <ListingReviewListContainer reviewList={getReviews(this.listing as any)} />;
    };
    _setTitleFromListing() {
      this.host.title = `Reviews for ${this.listing.title}`;
    }
  
    componentWillMount() {
      this._setupListing(this.props);
      this.listing.load();
      this._titleSetDisposer = autorun(() => {
        const loadSync = this.listing.loadSync;
        if (loadSync.syncing) {
          this.host.title = "Loading...";
        } else if (loadSync.error) {
          this.host.title = "Error";
        } else {
          this._setTitleFromListing();
        }
      });
    }
    componentWillReceiveProps(nextProps: IAppProps) {
      this._setupListing(nextProps);
    }
    componentWillUnount() {
      if (this._titleSetDisposer) {
        this._titleSetDisposer();
        delete this._titleSetDisposer;
      }
    }
  
    render() {
      return (
        <UserAccountHostView host={this.host}>
          <ListingContainer listing={this.listing} onRenderListing={this._onRenderListing} />
        </UserAccountHostView>
      );
    }
  }



// const storeFrontSectionTitleStyles = Object.assign({}, DefaultFontStyles.large, {
//   fontWeight: FontWeights.semibold
// });

// const ListingStoreFrontStylesheet = mergeStyleSets({
//   root: ["listing-store-front", {}],
//   header: [
//     "listing-store-front-header",
//     {
//       paddingTop: 8,
//       paddingBottom: 0,
//       paddingLeft: 16,
//       paddingRight: 16
//     }
//   ],
//   searchInputContainer: [
//     "listing-store-front-search-input-container",
//     {
//       selectors: {
//         ".ms-SearchBox": {
//           backgroundColor: DefaultPalette.white
//         }
//       }
//     }
//   ],
//   body: ["listing-store-front-body", {}],
//   section: [
//     "listing-store-front-section",
//     {
//       marginTop: 16
//     }
//   ],
//   sectionHeader: [
//     "listing-store-front-section-header",
//     {
//       marginLeft: 16
//     }
//   ],
//   sectionTitle: ["listing-store-front-section-title", storeFrontSectionTitleStyles],
//   sectionBody: ["listing-store-front-section-body", {}]
// });

// type IListingStoreFrontStyles = typeof ListingStoreFrontStylesheet;

// type IListingStoreFrontProps = {
//   storeFront?: ISyncSupplier<IListingStoreFront>;
//   onSelectItem?: (listing: IListing) => void;
//   onOpen?: (listing: IListing) => void;
//   onAdd?: () => void;
//   onShowAllListings?: () => void;
//   className?: string;
//   styles?: IListingStoreFrontStyles;
//   adminGroup?: string;
//   title?: any;
//   listKey?: string;
// };

// const ListingStoreFrontSection: React.FC<IListingStoreFrontProps> = observer((props) => {
//   return (
//     <div className={ListingStoreFrontStylesheet.section}>
//       <div className={ListingStoreFrontStylesheet.sectionHeader}>
//         <div className={ListingStoreFrontStylesheet.sectionTitle}>{props.title}</div>
//       </div>
//       <div className={ListingStoreFrontStylesheet.sectionBody}>{props.children}</div>
//     </div>
//   );
// });

// const ListingStoreFrontListSection = observer((props: IListingStoreFrontProps) => {
//   var _onRenderItem = (listing, idx, props) => {
//     return <ListingTile key={listing.id} listing={listing} onClick={props.onSelectItem} onLaunch={props.onOpen} />;
//   };
//   var _onRenderDone = () => {
//     const list = props.storeFront.value ? props.storeFront.value[props.listKey] : undefined;
//     if (list && list.length > 0) {
//       return (
//         <ListingList
//           compact
//           wrapping
//           listings={list}
//           onSelectItem={props.onSelectItem}
//           onRenderListing={_onRenderItem}
//         />
//       );
//     }
//     return <MessageBar messageBarType={MessageBarType.info}>No {props.title} Listings available</MessageBar>;
//   };

//   return (
//     <ListingStoreFrontSection title={props.title}>
//       <SyncComponent
//         sync={props.storeFront.sync}
//         onRenderDone={_onRenderDone}
//         syncLabel={`Loading ${props.title} Listings...`}
//       />
//     </ListingStoreFrontSection>
//   );
// });

// const ListingStoreFront = (props: IListingStoreFrontProps) => {
//   return (
//     <div className={ListingStoreFrontStylesheet.root}>
//       <ListingStoreFrontListSection {...props} listKey="featured" title="Featured" />
//       <ListingStoreFrontListSection {...props} listKey="most_popular" title="Most Popular" />
//       <ListingStoreFrontListSection {...props} listKey="recommended" title="Recommended" />
//       <ListingStoreFrontListSection {...props} listKey="recent" title="Recent" />
//     </div>
//   );
// };

// const ListingStoreFrontContainer = (props: IListingStoreFrontProps) => {
//   React.useEffect(() => {
//     props.storeFront.load();
//   });
//   var _onRenderDone = () => {
//     return <ListingStoreFront {...props} />;
//   };

//   return <SyncComponent sync={props.storeFront.sync} onRenderDone={_onRenderDone} />;
// };


// const renderIcon = (listingSupplier: IListingModelSupplier) => {
//   let icon;
//   if (listingSupplier.sync.syncing) {
//     icon = <Spinner size={SpinnerSize.small} />;
//   } else if (listingSupplier.sync.error) {
//     icon = <Icon iconName="Error" />;
//   } else if (listingSupplier.value.small_icon && listingSupplier.value.small_icon.url) {
//     icon = <Image src={listingSupplier.value.small_icon.url} width={16} height={16} />;
//   } else {
//     icon = <Icon iconName="Puzzle" />;
//   }
//   return icon;
// };

// interface IListingPreviewProps {
//   listing: IListing;
//   styles?: IListingPreviewStyles;
//   className?: string;
// }

// const ListingPreview = observer((props: IListingPreviewProps) => {
//   var _classNames = useListingPreviewStyles(props);
//   var _renderFallback = () => {
//     return (
//       <div className={_classNames.fallback}>
//         <Icon className={_classNames.fallbackIcon} iconName="Puzzle" />
//       </div>
//     );
//   };

//   let fallback;
//   let image;
//   if (props.listing.banner_icon && props.listing.banner_icon.url) {
//     image = <Image src={props.listing.banner_icon.url} alt={props.listing.title} width={220} height={137} />;
//   } else {
//     image = _renderFallback();
//   }
//   return <div className={_classNames.root}>{image}</div>;
// });

// const ListingTitleContainer = (props: IListingProps) => {
//   const _onRenderDone = () => {
//     return props.listing.title;
//   };

//   const _onRenderSync = () => {
//     return `Loading...`;
//   };
//   return (
//     <SyncComponent
//       sync={props.listing.loadSync}
//       //@ts-ignore
//       onRenderSync={_onRenderSync}
//       //@ts-ignore
//       onRenderDone={_onRenderDone}
//     />
//   );
// };


const useListingPreviewStyles = (props) => {
  const memoStyles = memoizeFunction((theme: ITheme) =>
    concatStyleSets({
      root: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        width: 228,
        height: 145
      },
      fallback: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        width: 220,
        height: 137,
        backgroundColor: DefaultPalette.neutralLight,
        color: DefaultPalette.themePrimary
      },
      fallbackIcon: {
        fontSize: FontSizes.xxLarge
      }
    })
  )

  let styles = memoStyles(props.theme || getTheme())

  return mergeStyleSets({
    root: ["listing-preview", props.className, styles.root],
    fallback: ["listing-preview-fallback", styles.fallback],
    fallbackIcon: ["listing-preview-fallback-icon", styles.fallbackIcon]
  })
}
