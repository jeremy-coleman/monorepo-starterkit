

import { AbstractAppHost } from "coglite/modules/host";
import { Sync } from "coglite/shared/models";
import { IRequest, IRouter } from "coglite/shared/router";
import { IConsumerFunc, IPredicateFunc, isFunction, ISupplierFunc } from "coglite/shared/util";
import { action, autorun, computed, IReactionDisposer, observable, reaction } from "mobx";
import { when } from 'when-switch';
import { ComponentTypes, Defaults, WindowResizeType } from "../constants";
import { dispatchWindowResize } from "../DOMHelper";


class ComponentRegistry {
  record = new Set()
  next(kind: string) {
    let i = 1
    while (this.record.has(`${kind}-comp-${i}`)) {
      i++
    }
    const id = `${kind}-comp-${i}`
    this.record.add(id)
    return id
  }
}

const componentRegistry = new ComponentRegistry()

var NotConfiguredComponentFactory: IComponentFactory = (type: string) => {
  throw {
    code: "ILLEGAL_STATE",
    message: "A component factory has not been configured"
  };
};



class Split {
    _id: string;
    @observable.ref parent: IComponent;
    @observable.ref _componentFactory: IComponentFactory;
    @observable.ref _addApp: IRequest | ISupplierFunc<IRequest>;
    @observable.ref _router: IRouter;
    @observable _closeDisabled: boolean;
    @observable _needsOverflow: boolean;
    @observable _x: number = 0;
    @observable _y: number = 0;
    @observable _width: number = 0;
    @observable _height: number = 0;
    type: string;
  
    get id() {
      if (!this._id) {
        this._id = componentRegistry.next(this.type);
        console.log(this._id)
      }
      return this._id;
    }
  
    get isWindowManager() {
      return false;
    }
  
    @computed
    get isOverflow() {
      return false;
    }
  
    @action
    resetViewport() {
      this._x = 0;
      this._y = 0;
      this._width = 0;
      this._height = 0;
    }
  
    @computed
    get root() {
      return this.parent ? this.parent.root : this;
    }
  
    @computed
    get x() {
      return this._x;
    }
  
    @computed
    get rx() {
      return this.x - (this.parent ? this.parent.x : 0);
    }
  
    @computed
    get y() {
      return this._y;
    }
  
    @computed
    get ry() {
      return this.y - (this.parent ? this.parent.y : 0);
    }
  
    @computed
    get width() {
      return this._width;
    }
  
    @computed
    get height() {
      return this._height;
    }
  
    @action
    resize(width: number, height: number) {
      if (
        (width >= 0 && width !== this._width) ||
        (height >= 0 && height !== this._height)
      ) {
        this._width = width;
        this._height = height;
      }
    }
  
    @action
    position(x: number, y: number) {
      this._x = x;
      this._y = y;
    }
  
    @action
    setViewport(x: number, y: number, width: number, height: number) {
      this.position(x, y);
      this.resize(width, height);
    }
  
    @computed
    get addApp() {
      if (this._addApp !== undefined) {
        return this._addApp;
      }
      const p = this.parent;
      if (p === this) {
        console.warn("-- Ancestor Resolution Cycle Detected");
        return undefined;
      }
      return p ? p.addApp : undefined;
    }
  
    set addApp(addApp: IRequest | ISupplierFunc<IRequest>) {
      this.setAddApp(addApp);
    }
  
    @computed
    get componentFactory(): IComponentFactory {
      if (this._componentFactory !== undefined) {
        return this._componentFactory;
      }
      const p = this.parent;
      if (p === this) {
        console.warn("-- Ancestor Resolution Cycle Detected");
        return undefined;
      }
      return p ? p.componentFactory : NotConfiguredComponentFactory;
    }
    set componentFactory(value) {
      this.setComponentFactory(value);
    }
    @action
    setComponentFactory(componentFactory: IComponentFactory) {
      this._componentFactory = componentFactory;
    }
  
    @computed
    get closeDisabled(): boolean {
      if (this._closeDisabled !== undefined) {
        return this._closeDisabled;
      }
      const p = this.parent;
      if (p === this) {
        console.warn("-- Ancestor Resolution Cycle Detected");
        return undefined;
      }
      return p ? p.closeDisabled : false;
    }
    set closeDisabled(value) {
      this.setCloseDisabled(value);
    }
    @action
    setCloseDisabled(closeDisabled: boolean) {
      this._closeDisabled = closeDisabled;
    }
  
    @action
    setAddApp(addApp: IRequest | ISupplierFunc<IRequest>) {
      this._addApp = addApp;
    }
  
    @computed
    get router() {
      if (this._router !== undefined) {
        return this._router;
      }
      const p = this.parent;
      if (p === this) {
        console.warn("-- Ancestor Resolution Cycle Detected");
        return undefined;
      }
      return p ? p.router : undefined;
    }
    set router(value) {
      this.setRouter(value);
    }
  
    @action
    setRouter(router: IRouter) {
      this._router = router;
    }
  
    @computed
    get dashboard(): IDashboard {
      const p = this.parent;
      if (p === this) {
        console.warn("-- Dashboard Resolution Cycle Detected");
        return undefined;
      }
      return p ? p.dashboard : undefined;
    }
  
    removeFromParent() {
      if (this.parent) {
        this.parent.remove(this);
        this.parent = undefined;
      }
    }
  
    get config() {
      // default impl
      return undefined;
    }
    set config(value) {
      this.setConfig(value);
    }
    @action
    setConfig(config: any): void {
      // does nothing
    }
  
  
    visit(callback: IConsumerFunc<IComponent>): void {
      callback(this);
    }
  
  
  
    findFirst(predicate: IPredicateFunc<IComponent, IComponent[]>) {
      if (predicate(this)) {
        return this;
      }
      return this._findFirstChild(predicate);
    }
  
    findAll(predicate: IPredicateFunc<IComponent>): IComponent[] {
      let r = [];
      if (predicate(this)) {
        r.push(this);
      }
      const tr = this._findAllChildren(predicate);
      if (tr && tr.length > 0) {
        r = r.concat(tr);
      }
      return r;
    }
  
  
    toJSON() {
      return this.config;
    }
      @observable _offset : number;
      @observable _first : IComponent;
      @observable _second : IComponent;
      @observable _splitActive : boolean = false;
  
      @computed
      get splitActive() {
          return this._splitActive;
      }
      set splitActive(value) {
          this.setSplitActive(value);
      }
      
      @action
      setSplitActive(splitActive : boolean) {
          this._splitActive = splitActive;
          const db = this.dashboard;
          if(splitActive) {
              db.setBlockSource(this);
          } else if(db.blockSource === this) {
              db.clearBlockSource();
          }
      }
  
      @computed
      get first() {
          return this._first;
      }
      set first(value : IComponent) {
          this.setFirst(value);
      }
  
      @action
      setFirst(first : IComponent) {
          if(first !== this._first) {
              if(first && first.parent !== this) {
                  first.removeFromParent();
              }
              this._first = first;
              if(this._first) {
                  this._first.parent = this;
              }
          }
      }
  
      @computed
      get firstConfig() {
          return this._first ? { component: this._first.config } : undefined;
      }
      
      @action
      setFirstConfig(config : any) {
          let first : IComponent;
          if(config && config.component) {
              first = this.componentFactory(config.component.type);
          }
          // NOTE: if this order seems odd it's because we want the hierarchy established
          // before setting the code (otherwise subsequent componentFactory usage is dodgy)
          this.setFirst(first);
          if(first) {
              first.setConfig(config.component);
          }
      }
  
      @computed
      get second() {
          return this._second;
      }
  
      set second(value : IComponent) {
          this.setSecond(value);
      }
  
      @computed
      get secondConfig() {
          return this._second ? { component: this._second.config } : undefined;
      }
  
      @action
      setSecond(second : IComponent) {
          if(second !== this._second) {
              if(second && second.parent !== this) {
                  second.removeFromParent();
              }
              this._second = second;
              if(this._second) {
                  this._second.parent = this;
              }
          }
      }
  
      @action
      setSecondConfig(config : any) {
          let second : IComponent;
          if(config && config.component) {
              second = this.componentFactory(config.component.type);
          }
          // NOTE: if this order seems odd it's because we want the hierarchy established
          // before setting the code (otherwise subsequent componentFactory usage is dodgy)
          this.setSecond(second);
          if(second) {
              second.setConfig(config.component);
          }
      }
  
      @computed
      get offset() {
          return this._offset !== undefined ? this._offset : Defaults.offset;
      }
      set offset(value : number) {
          this.setOffset(value);
      }
  
      @action
      setOffset(offset : number) {
          if(offset >= 0) {
              this._offset = offset;
          }
      }
  
      @action
      replace(newComp : IComponent, oldComp : IComponent) : void {
          if(oldComp === this._first || oldComp === this._second) {
              if(oldComp === this._first) {
                  this.setFirst(newComp);
              } else if(oldComp === this._second) {
                  this.setSecond(newComp);
              }
          }
      }
      
      @action
      remove(comp : IComponent) {
          if(comp === this._first || comp === this._second) {
              const replacement = comp === this._first ? this._second : this._first;
              // clear the parent for both left and right
              if(this._first) {
                  this._first.parent = undefined;
              }
              if(this._second) {
                  this._second.parent = undefined;
              }
              if(this.parent) {
                  this.parent.replace(replacement, this);
              }
          }
      }
  
      _visitChildren(callback) {
          if(this._first) {
              this._first.visit(callback);
          }
          if(this._second) {
              this._second.visit(callback);
          }
      }
  
      _findFirstChild(predicate) {
          let r: IComponent;
          if(this._first) {
              r = this._first.findFirst(predicate);
          }
          if(!r) {
              r = this._second.findFirst(predicate);
          }
          return r;
      }
  
      _findAllChildren(predicate) : IComponent[] {
          let r = [];
          const lr = this._first ? this._first.findAll(predicate) : undefined;
          const rr = this._second ? this._second.findAll(predicate) : undefined;
          if(lr) {
              r = r.concat(lr);
          }
          if(rr) {
              r = r.concat(rr);
          }
          return r;
      }
  
      @action
      close() {
          if(this.first) {
              this.first.close();
          }
          if(this.second) {
              this.second.close();
          }
      }
  }
  

export type IWindowManager = WindowManager

class WindowManager {
    _id: string;
    @observable.ref parent: IComponent;
    @observable.ref _componentFactory: IComponentFactory;
    @observable.ref _addApp: IRequest | ISupplierFunc<IRequest>;
    @observable.ref _router: IRouter;
    @observable _closeDisabled: boolean;
    @observable _needsOverflow: boolean;
    @observable _x: number = 0;
    @observable _y: number = 0;
    @observable _width: number = 0;
    @observable _height: number = 0;
  
    get id() {
      if (!this._id) {
        this._id = componentRegistry.next(this.type);
        console.log(this._id)
      }
      return this._id;
    }
  
    @computed
    get isOverflow() {
      return false;
    }
  
    @action
    resetViewport() {
      this._x = 0;
      this._y = 0;
      this._width = 0;
      this._height = 0;
    }
  
    @computed
    get root() {
      return this.parent ? this.parent.root : this;
    }
  
    @computed
    get x() {
      return this._x;
    }
  
    @computed
    get rx() {
      return this.x - (this.parent ? this.parent.x : 0);
    }
  
    @computed
    get y() {
      return this._y;
    }
  
    @computed
    get ry() {
      return this.y - (this.parent ? this.parent.y : 0);
    }
  
    @computed
    get width() {
      return this._width;
    }
  
    @computed
    get height() {
      return this._height;
    }
  
    @action
    resize(width: number, height: number) {
      if (
        (width >= 0 && width !== this._width) ||
        (height >= 0 && height !== this._height)
      ) {
        this._width = width;
        this._height = height;
      }
    }
  
    @action
    position(x: number, y: number) {
      this._x = x;
      this._y = y;
    }
  
    @action
    setViewport(x: number, y: number, width: number, height: number) {
      this.position(x, y);
      this.resize(width, height);
    }
  
    @computed
    get addApp() {
      if (this._addApp !== undefined) {
        return this._addApp;
      }
      const p = this.parent;
      if (p === this) {
        console.warn("-- Ancestor Resolution Cycle Detected");
        return undefined;
      }
      return p ? p.addApp : undefined;
    }
  
    set addApp(addApp: IRequest | ISupplierFunc<IRequest>) {
      this.setAddApp(addApp);
    }
  
    @computed
    get componentFactory(): IComponentFactory {
      if (this._componentFactory !== undefined) {
        return this._componentFactory;
      }
      const p = this.parent;
      if (p === this) {
        console.warn("-- Ancestor Resolution Cycle Detected");
        return undefined;
      }
      return p ? p.componentFactory : NotConfiguredComponentFactory;
    }
    set componentFactory(value) {
      this.setComponentFactory(value);
    }
    @action
    setComponentFactory(componentFactory: IComponentFactory) {
      this._componentFactory = componentFactory;
    }
  
    @computed
    get closeDisabled(): boolean {
      if (this._closeDisabled !== undefined) {
        return this._closeDisabled;
      }
      const p = this.parent;
      if (p === this) {
        console.warn("-- Ancestor Resolution Cycle Detected");
        return undefined;
      }
      return p ? p.closeDisabled : false;
    }
    set closeDisabled(value) {
      this.setCloseDisabled(value);
    }
    @action
    setCloseDisabled(closeDisabled: boolean) {
      this._closeDisabled = closeDisabled;
    }
  
    @action
    setAddApp(addApp: IRequest | ISupplierFunc<IRequest>) {
      this._addApp = addApp;
    }
  
    @computed
    get router() {
      if (this._router !== undefined) {
        return this._router;
      }
      const p = this.parent;
      if (p === this) {
        console.warn("-- Ancestor Resolution Cycle Detected");
        return undefined;
      }
      return p ? p.router : undefined;
    }
    set router(value) {
      this.setRouter(value);
    }
  
    @action
    setRouter(router: IRouter) {
      this._router = router;
    }
  
    @computed
    get dashboard(): IDashboard {
      const p = this.parent;
      if (p === this) {
        console.warn("-- Dashboard Resolution Cycle Detected");
        return undefined;
      }
      return p ? p.dashboard : undefined;
    }
  
    removeFromParent() {
      if (this.parent) {
        this.parent.remove(this);
        this.parent = undefined;
      }
    }
  
    get config() {
      // default impl
      return undefined;
    }
    set config(value) {
      this.setConfig(value);
    }
    @action
    setConfig(config: any): void {}
  
  
  
    visit(callback: IConsumerFunc<IComponent>): void {
      callback(this);
    }
  
  
  
    findFirst(predicate: IPredicateFunc<IComponent, IComponent[]>) {
      if (predicate(this)) {
        return this;
      }
      return this._findFirstChild(predicate);
    }
  
    findAll(predicate: IPredicateFunc<IComponent>): IComponent[] {
      let r = [];
      if (predicate(this)) {
        r.push(this);
      }
      const tr = this._findAllChildren(predicate);
      if (tr && tr.length > 0) {
        r = r.concat(tr);
      }
      return r;
    }
  
    toJSON() {
      return this.config;
    }
  
    @observable windows: IWindow[] = [];
    @observable _windowSettings = new WindowSettings();
    @observable.ref _resizing: IWindow;
    @observable _resizeType: WindowResizeType;
    @observable.ref _drag: IWindow;
    @observable _activeIndex: number;
    @observable _maximizedIndex: number;
  
    get type() {
      return null;
    }
  
    @computed
    get isRequiresOverflow() {
      return false;
    }
  
    @computed
    get windowSettings() {
      if(this.type === "stack") this._windowSettings["role"] = "tabpanel"
      return this._windowSettings;
    }
    
    @computed
    get first() {
      return this.windowCount > 0 ? this.windows[0] : undefined;
    }
  
    @computed
    get last() {
      return this.windowCount > 0
        ? this.windows[this.windows.length - 1]
        : undefined;
    }
  
    @computed
    get windowCount(): number {
      return this.windows ? this.windows.length : 0;
    }
  
    get isWindowManager() {
      return true;
    }
  
    @action
    add(win: IWindow, opts?: any): void {
      if (win) {
        if (win.parent !== this) {
          win.removeFromParent();
          win.parent = this;
        } else {
          const itemIdx = this.windows.indexOf(win);
          this.windows.splice(itemIdx, 1);
        }
        this.windows.push(win);
        if ((opts && opts.makeActive) || this.windows.length === 1) {
          this.setActive(win);
        }
      }
      dispatchWindowResize()
    }
  
    @action
    addNew(opts?: any) {
      if (this.addApp) {
        let addApp = isFunction(this.addApp)
          ? (this.addApp as ISupplierFunc<IRequest>)()
          : this.addApp;
        if (opts) {
          addApp = Object.assign({}, addApp, opts);
        }
        return this.open(addApp);
      }
      return Promise.resolve();
    }
  
    @action
    insertAt(item: IWindow, index: number) {
      if (item && index >= 0 && index < this.windows.length) {
        let refStackItem = this.windows[index];
        let insertIdx: number = -1;
        if (item.parent !== this) {
          item.removeFromParent();
          item.parent = this;
          insertIdx = index;
        } else {
          const itemIdx = this.windows.indexOf(item);
          if (itemIdx >= 0 && itemIdx !== index) {
            this.windows.splice(itemIdx, 1);
            insertIdx = this.windows.indexOf(refStackItem);
          }
        }
  
        if (insertIdx >= 0) {
          this.windows.splice(insertIdx, 0, item);
        }
      } else {
        this.add(item);
      }
    }
  
    @action
    insertBefore(item: IWindow, refItem?: IWindow) {
      if (!refItem) {
        this.add(item);
      } else if (item) {
        this.insertAt(item, this.windows.indexOf(refItem));
      }
    }
  
    @action
    replace(newItem: IComponent, oldItem: IComponent): void {
      if (newItem && oldItem && oldItem.parent === this) {
        this.insertBefore(newItem as IWindow, oldItem as IWindow);
        oldItem.removeFromParent();
      }
    }
  
    @action
    open(request: WindowRequest): Promise<IWindow> {
      let win: any | IWindow;
      if (request && request.replace && request.name) {
        const db = this.dashboard;
        win = db.findFirst((w: IWindow) => {
          return w.type === "window"
            ? (w as IWindow).name === request.name
            : false;
        });
      }
      if (!win) {
        win = new Window();
        if (request) {
          win.name = request.name;
          win.setPath(request.path);
          win.setParams(request.params);
          win.setQuery(request.query);
          win.setTitle(request.title);
          win.setTransient(request.transient ? true : false);
          if (request.transient && request.opener) {
            const opener = request.opener //as IAppHost;
            win.icon.url = opener.icon.url;
            win.icon.text = opener.icon.text;
            win.icon.name = opener.icon.name;
            win.icon.component = opener.icon.component;
          }
        }
        this.add(win, Object.assign({}, request, { makeActive: true }));
      } else {
        win.load(request);
      }
      return Promise.resolve(win);
    }
  
    _visitChildren(callback) {
      this.windows.forEach(w => w.visit(callback));
    }
  
    _findFirstChild(predicate) {
      let r;
      this.windows.some(w => {
        r = w.findFirst(predicate);
        return r ? true : false;
      });
      return r;
    }
  
    _findAllChildren(predicate): IComponent[] {
      let r = [];
      let wr;
      this.windows.forEach(w => {
        wr = w.findAll(predicate);
        if (wr && wr.length > 0) {
          r = r.concat(wr);
        }
      });
      return r;
    }
  
    @action
    remove(node: IComponent) {
      const idx = this.windows.indexOf(node as IWindow);
      if (idx >= 0) {
        const w = this.windows[idx];
        w.parent = undefined;
        this.windows.splice(idx, 1);
  
        if (this.windows.length === 0) {
          this.removeFromParent();
        }
      }
    }
  
    @action
    close() {
      //if (this.id === "stack-comp-1") return
      if (!this.closeDisabled) {
        while (this.windowCount > 0) {
          this.windows[0].close();
        }
        this.removeFromParent();
      }
      //if (!this.closeDisabled) {}
  
    }
  
    _onDragStart(drag: IWindow) {
      // does nothing by default
    }
  
    _onDragEnd() {
      // does nothing by default
    }
  
    @computed
    get drag() {
      return this._drag;
    }
    @action
    dragStart(drag: IWindow) {
      if (this.dashboard) {
        this.dashboard.dragStart(drag);
      }
      this._drag = drag;
      this._onDragStart(drag);
    }
    @action
    dragEnd(): void {
      if (this.dashboard) {
        this.dashboard.dragEnd();
      }
      this._drag = undefined;
      this._onDragEnd();
    }
  
    @computed
    get resizing() {
      return this._resizing;
    }
  
    @computed
    get resizeType() {
      return this._resizeType;
    }
  
    _onResizeStart(win: IWindow) {
      // does nothing by default
    }
  
    _onResizeEnd() {
      // does nothing by default
    }
  
    @action
    resizeStart(win: IWindow, type: WindowResizeType) {
      this._resizing = win;
      this._resizeType = type;
      this._onResizeStart(win);
    }
  
    @action
    resizeEnd() {
      this._resizing = undefined;
      this._resizeType = undefined;
      this._onResizeEnd();
    }
  
    @computed
    get activeIndex() {
      if (this._activeIndex >= 0 && this._activeIndex < this.windowCount) {
        return this._activeIndex;
      }
      if (this._activeIndex >= this.windowCount && this.windowCount > 0) {
        return this.windowCount - 1;
      }
      return 0;
    }
    set activeIndex(value) {
      this.setActiveIndex(value);
    }
  
    @action
    setActiveIndex(activeIndex: number) {
      if (activeIndex !== this._activeIndex) {
        this._activeIndex = activeIndex;
      }
    }
  
    @computed
    get active(): IWindow {
      const activeIndex = this.activeIndex;
      return activeIndex >= 0 && activeIndex < this.windowCount
        ? this.windows[activeIndex]
        : undefined;
    }
    set active(value: IWindow) {
      this.setActive(value);
    }
  
    @action
    setActive(active: IWindow) {
      this.setActiveIndex(this.windows.indexOf(active));
    }
  
    @computed
    get maximizedIndex() {
      return this._maximizedIndex;
    }
    set maximizedIndex(value) {
      this.setMaximizedIndex(value);
    }
  
    @action
    setMaximizedIndex(maximizedIndex: number) {
      if (maximizedIndex !== this._maximizedIndex) {
        this._maximizedIndex = maximizedIndex;
      }
    }
  
    @computed
    get maximized(): IWindow {
      const maximizedIndex = this.maximizedIndex;
      return maximizedIndex !== undefined &&
        maximizedIndex >= 0 &&
        maximizedIndex < this.windows.length
        ? this.windows[maximizedIndex]
        : undefined;
    }
    set maximized(value: IWindow) {
      this.setMaximized(value);
    }
    @action
    setMaximized(maximized: IWindow) {
      this.setMaximizedIndex(
        maximized ? this.windows.indexOf(maximized) : undefined
      );
      if (maximized) {
        this.setActive(maximized);
      }
    }
  
  }
  
  